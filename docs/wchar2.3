.TH "include/wchar2.h" 3 "Sun Aug 5 2018" "libwchar2 0.0.8" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/wchar2.h
.SH SYNOPSIS
.br
.PP
\fC#include <wctype\&.h>\fP
.br
\fC#include <wchar\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBstring_ws\fP"
.br
.RI "Base wide string structure\&. "
.ti -1c
.RI "struct \fB_wdirent\fP"
.br
.RI "the contains constructs that facilitate directory traversing "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBUSED_WCHAR2LIB\fP   1"
.br
.RI "Define this flag for other software, indicate enable \fClibwchar2\fP in you project\&. "
.ti -1c
.RI "#define \fB__WS\fP(x)   __WS_(x)"
.br
.RI "static string to wide type macro "
.ti -1c
.RI "#define \fB__WSTR\fP   wchar_t"
.br
.RI "definition wchar_t string macro "
.ti -1c
.RI "#define \fB__WSTRFREE\fP   __attribute__((cleanup(__wsfree))) \fB__WSTR\fP"
.br
.RI "auto free wchar_t string macro "
.ti -1c
.RI "#define \fB__WSTR_FMT\fP   'ls'"
.br
.RI "print format wchar_t string macro "
.ti -1c
.RI "#define \fB__WCHAR_FMT\fP   'lc'"
.br
.RI "print format wchar_t char macro "
.ti -1c
.RI "#define \fB__WCSZ\fP(x)   ((x\->sz + 1) * sizeof(wchar_t))"
.br
.RI "determine size \fBstring_ws\fP macro "
.ti -1c
.RI "#define \fBwstring_appends\fP(A, \&.\&.\&.)   \fBwstring_appends_\fP(A,__VA_ARGS__,NULL)"
.br
.RI "Macro to function \fBwstring_appends_()\fP, see notes\&. "
.ti -1c
.RI "#define \fBwreaddir_cb_opt\fP(opt,  val)   ((opt) | (1L << (val)))"
.br
.RI "Macro to set options value to function \fB_wreaddir_cb\fP\&. "
.ti -1c
.RI "#define \fBwstocscvt\fP(A,  B,  D)"
.br
.RI "wchar_t* type to char[] A char[] - array name B wchar_t* - source D - function return value if error "
.ti -1c
.RI "#define \fBwstocsncvt\fP(A,  B,  C,  D)"
.br
.RI "wchar_t* type to char[] with size A char[] - array name B wchar_t* - source C size_t - wchar_t* size D - function return value if error "
.ti -1c
.RI "#define \fBwstrtocscvt\fP(A,  B,  D)"
.br
.RI "\fBstring_ws\fP type to char[] this struct defined on top of this file A char[] - array name B string_ws* - source D - function return value if error "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned long long int \fBuintmax_t\fP"
.br
.ti -1c
.RI "typedef long long int \fBintmax_t\fP"
.br
.ti -1c
.RI "typedef struct \fB_wdirent\fP \fBwdirent_t\fP"
.br
.RI "the contains constructs that facilitate directory traversing "
.ti -1c
.RI "typedef void \fBWDIR_t\fP"
.br
.RI "Main structure directory traversing, reference to \fCvoid\fP "
.ti -1c
.RI "typedef void(* \fBwdir_cb\fP) (unsigned int, \fBaccess_e\fP, long long, \fBstring_ws\fP *, void *)"
.br
.RI "CallBack for \fB_wreaddir_cb\fP\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBaccess_e\fP { \fBISERR\fP = -1, \fBISUNK\fP = 0, \fBISFIL\fP = 1, \fBISLNK\fP = 2, \fBISDIR\fP = 3, \fBISCHR\fP = 4, \fBISBLK\fP = 5, \fBISSOCK\fP = 6, \fBISFIFO\fP = 7, \fBISWHT\fP = 8, \fBDIRNODIR\fP = 9, \fBDIRNOROOT\fP = 10, \fBDIRENTRYSIZE\fP = 11 }"
.br
.RI "enumeration for return waccess function "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBwchar2version\fP (void)"
.br
.RI "Library current version\&. "
.ti -1c
.RI "wchar_t \fB_towupper\fP (wchar_t)"
.br
.RI "Translate wide characters to uppercase\&. "
.ti -1c
.RI "wchar_t \fB_towlower\fP (wchar_t)"
.br
.RI "Translate wide characters to lowercase\&. "
.ti -1c
.RI "wchar_t \fB_towctrans\fP (wchar_t, wctrans_t)"
.br
.RI "Extensible wide-character translation\&. "
.ti -1c
.RI "wctype_t \fB_wctype\fP (const char *)"
.br
.RI "Compute wide-character test type\&. "
.ti -1c
.RI "wctrans_t \fB_wctrans\fP (const char *)"
.br
.RI "Compute wide-character translation type\&. "
.ti -1c
.RI "int \fB_wcwidth\fP (wchar_t)"
.br
.RI "Number of column positions of a wide-character code\&. "
.ti -1c
.RI "int \fB_wcswidth\fP (const wchar_t *, size_t)"
.br
.RI "Number of column positions of a wide-character string\&. "
.ti -1c
.RI "int \fB_iswctype\fP (wchar_t, wctype_t)"
.br
.RI "Extensible wide-character test, wide-character classification\&. "
.ti -1c
.RI "int \fB_iswxdigit\fP (wchar_t)"
.br
.RI "Test for hexadecimal digit wide character\&. "
.ti -1c
.RI "int \fB_iswupper\fP (wchar_t)"
.br
.RI "Test for uppercase wide character\&. "
.ti -1c
.RI "int \fB_iswspace\fP (wchar_t)"
.br
.RI "Test for whitespace wide character\&. "
.ti -1c
.RI "int \fB_iswpunct\fP (wchar_t)"
.br
.RI "Test for punctuation or symbolic wide character\&. "
.ti -1c
.RI "int \fB_iswprint\fP (wchar_t)"
.br
.RI "Test for printing wide character\&. "
.ti -1c
.RI "int \fB_iswlower\fP (wchar_t)"
.br
.RI "Ttest for lowercase wide character\&. "
.ti -1c
.RI "int \fB_iswgraph\fP (wchar_t)"
.br
.RI "Test for graphic wide character\&. "
.ti -1c
.RI "int \fB_iswdigit\fP (wchar_t)"
.br
.RI "Test for decimal digit wide character\&. "
.ti -1c
.RI "int \fB_iswcntrl\fP (wchar_t)"
.br
.RI "Test for control wide character\&. "
.ti -1c
.RI "int \fB_iswblank\fP (wchar_t)"
.br
.RI "Test for whitespace wide character\&. "
.ti -1c
.RI "int \fB_iswalpha\fP (wchar_t)"
.br
.RI "Test for whitespace wide character, alphabetic wide character predicate\&. "
.ti -1c
.RI "int \fB_iswalnum\fP (wchar_t)"
.br
.RI "Test for alphanumeric wide character, alphabetic wide character predicate\&. "
.ti -1c
.RI "double \fB_wcstod\fP (const wchar_t *, wchar_t **)"
.br
.RI "Convert wide character ASCII string to \fCdouble\fP number\&. "
.ti -1c
.RI "float \fB_wcstof\fP (const wchar_t *, wchar_t **)"
.br
.RI "Convert wide character ASCII string to \fCfloat\fP number\&. "
.ti -1c
.RI "long double \fB_wcstold\fP (const wchar_t *, wchar_t **)"
.br
.RI "Convert wide character ASCII string to \fClong double\fP number\&. "
.ti -1c
.RI "long int \fB_wcstol\fP (const wchar_t *, wchar_t **, int)"
.br
.RI "Convert wide character ASCII string to \fClong int\fP number\&. "
.ti -1c
.RI "long long int \fB_wcstoll\fP (const wchar_t *, wchar_t **, int)"
.br
.RI "Convert wide character ASCII string to \fClong long int\fP number\&. "
.ti -1c
.RI "unsigned long int \fB_wcstoul\fP (const wchar_t *, wchar_t **, int)"
.br
.RI "Convert wide character ASCII string to \fCunsigned long int\fP number\&. "
.ti -1c
.RI "unsigned long long int \fB_wcstoull\fP (const wchar_t *, wchar_t **, int)"
.br
.RI "Convert wide character ASCII string to \fCunsigned long long int\fP number\&. "
.ti -1c
.RI "intmax_t \fB_wcstoimax\fP (const wchar_t *, wchar_t **, int)"
.br
.RI "Convert wide character ASCII string to \fCintmax_t\fP integer\&. "
.ti -1c
.RI "uintmax_t \fB_wcstoumax\fP (const wchar_t *, wchar_t **, int)"
.br
.RI "Convert wide character ASCII string to \fCuintmax_t\fP integer\&. "
.ti -1c
.RI "size_t \fB_wcstombs\fP (char *restrict, const wchar_t *restrict, size_t)"
.br
.RI "Minimal wide string to multibyte string converter\&. "
.ti -1c
.RI "size_t \fB_wcstombs_s\fP (char *restrict, const wchar_t *restrict, size_t)"
.br
.RI "Minimal wide string to multibyte string converter + double size out buffer\&. "
.ti -1c
.RI "size_t \fB_wcsrtombs\fP (char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)"
.br
.RI "Convert a wide-character string to a character string\&. "
.ti -1c
.RI "size_t \fB_wcrtomb\fP (char *restrict, wchar_t, mbstate_t *restrict)"
.br
.RI "Convert wide character to multibyte sequence\&. "
.ti -1c
.RI "size_t \fB_mbstowcs\fP (wchar_t *restrict, const char *restrict, size_t)"
.br
.RI "Minimal multibyte string to wide string converter\&. "
.ti -1c
.RI "size_t \fB_mbsrtowcs\fP (wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)"
.br
.RI "Convert a character string to a wide-character string\&. "
.ti -1c
.RI "size_t \fB_wcsnrtombs\fP (char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)"
.br
.RI "Convert a wide-character string to a character string\&. "
.ti -1c
.RI "size_t \fB_mbsnrtowcs\fP (wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)"
.br
.RI "Convert a character string to a wide-character string\&. "
.ti -1c
.RI "size_t \fB_mbrtowc\fP (wchar_t *restrict, const char *restrict src, size_t, mbstate_t *restrict)"
.br
.RI "Converts a narrow multibyte character to a wide character\&. "
.ti -1c
.RI "size_t \fB_mbrlen\fP (const char *restrict, size_t, mbstate_t *restrict)"
.br
.RI "Get length of multibyte character\&. "
.ti -1c
.RI "int \fB_mblen\fP (const char *, size_t)"
.br
.RI "Determines the size, in bytes, of the multibyte character whose first byte is pointed\&. "
.ti -1c
.RI "int \fB_mbsinit\fP (const mbstate_t *)"
.br
.RI "Check if initial conversion state\&. "
.ti -1c
.RI "int \fB_mbtowc\fP (wchar_t *restrict, const char *restrict, size_t)"
.br
.RI "Minimal multibyte to wide char converter\&. "
.ti -1c
.RI "int \fB_wctomb\fP (char *, wchar_t)"
.br
.RI "Minimal wide char to multibyte converter\&. "
.ti -1c
.RI "int \fB_wctob\fP (wchar_t)"
.br
.RI "Convert wide character to single byte\&. "
.ti -1c
.RI "wchar_t \fB_btowc\fP (int)"
.br
.RI "Convert single byte character to wide character\&. "
.ti -1c
.RI "void \fBwcprint\fP (wchar_t *)"
.br
.RI "wchar_t* print This function to test variably only! Instead use _vfprintf, _vfwprintf, _fprintf, _fwprintf "
.ti -1c
.RI "int \fBwcstocscmp\fP (const char *, wchar_t *, size_t)"
.br
.RI "compare char* <-> wchar_t* This function quick compare only ASCII range, NOT all Unicode symbols support! size_t - wchar_t* size return - boolean "
.ti -1c
.RI "wchar_t * \fBwcsregexp\fP (wchar_t *restrict, wchar_t *restrict, int *)"
.br
.RI "wcsregexp - Matches a regular expression "
.ti -1c
.RI "size_t \fBu8stowcs\fP (wchar_t *, const char *)"
.br
.RI "Covert utf-8 char* to wchar_t* wchar_t* - output const char* - input return size_t - size\&. "
.ti -1c
.RI "size_t \fBwcstou8s\fP (char *, const wchar_t *)"
.br
.RI "Convert wchar_t* to utf-8 char* char* - output const wchar_t* - input return size_t - size\&. "
.ti -1c
.RI "int \fBu8sverify\fP (const char *)"
.br
.RI "Verify char* to utf-8 valid string const char* - input int (bool) - output\&. "
.ti -1c
.RI "wchar_t * \fB_wcpcpy\fP (wchar_t *, const wchar_t *)"
.br
.RI "Copy a wide-character string returning a pointer to its end\&. "
.ti -1c
.RI "wchar_t * \fB_wcpncpy\fP (wchar_t *, const wchar_t *, size_t)"
.br
.RI "Copy part of a wide-character string returning a pointer to its end\&. "
.ti -1c
.RI "wchar_t * \fB_wcscat\fP (wchar_t *, const wchar_t *)"
.br
.RI "Concatenate wide-character strings\&. "
.ti -1c
.RI "wchar_t * \fB_wcsncat\fP (wchar_t *, const wchar_t *, size_t)"
.br
.RI "Concatenate wide-character strings with size\&. "
.ti -1c
.RI "wchar_t * \fB_wcsncpy\fP (wchar_t *, const wchar_t *, size_t)"
.br
.RI "Counted copy wide-character string\&. "
.ti -1c
.RI "wchar_t * \fB_wcspbrk\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Find wide characters in string\&. "
.ti -1c
.RI "wchar_t * \fB_wcschr\fP (const wchar_t *, wchar_t)"
.br
.RI "Search for wide character in string\&. "
.ti -1c
.RI "wchar_t * \fB_wcsrchr\fP (const wchar_t *, wchar_t)"
.br
.RI "Reverse search for wide character in string\&. "
.ti -1c
.RI "wchar_t * \fB_wcsstr\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Find wide-character string segment\&. "
.ti -1c
.RI "wchar_t * \fB_wcstok\fP (wchar_t *, const wchar_t *, wchar_t **)"
.br
.RI "Tokenize wide-character string\&. "
.ti -1c
.RI "wchar_t * \fB_wmemchr\fP (const wchar_t *, wchar_t, size_t)"
.br
.RI "Find wide character in memory\&. "
.ti -1c
.RI "wchar_t * \fB_wmemcpy\fP (wchar_t *, const wchar_t *, size_t)"
.br
.RI "Copy wide characters in memory\&. "
.ti -1c
.RI "wchar_t * \fB_wmemmove\fP (wchar_t *, const wchar_t *, size_t)"
.br
.RI "Copy wide characters in memory with overlapping areas\&. "
.ti -1c
.RI "wchar_t * \fB_wmemset\fP (wchar_t *, wchar_t, size_t)"
.br
.RI "Set wide characters in memory\&. "
.ti -1c
.RI "size_t \fB_wcslcat\fP (wchar_t *, const wchar_t *, size_t)"
.br
.RI "Concatenate wide-character strings to specified length\&. "
.ti -1c
.RI "size_t \fB_wcslcpy\fP (wchar_t *, const wchar_t *, size_t)"
.br
.RI "Copy wide-character string to specified length\&. "
.ti -1c
.RI "size_t \fB_wcslen\fP (const wchar_t *)"
.br
.RI "Wide-character string length\&. "
.ti -1c
.RI "size_t \fB_wcsnlen\fP (const wchar_t *, size_t)"
.br
.RI "Wide-character string length with maximum limit\&. "
.ti -1c
.RI "size_t \fB_wcsspn\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Find initial match in wide-character string\&. "
.ti -1c
.RI "int \fB_wcscasecmp\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Case-insensitive wide character string compare\&. "
.ti -1c
.RI "int \fB_wcsncasecmp\fP (const wchar_t *, const wchar_t *, size_t)"
.br
.RI "Case-insensitive wide character string compare with size\&. "
.ti -1c
.RI "int \fB_wcscmp\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Wide-character string compare\&. "
.ti -1c
.RI "int \fB_wcsncmp\fP (const wchar_t *, const wchar_t *, size_t)"
.br
.RI "Wide-character string compare\&. "
.ti -1c
.RI "int \fB_wmemcmp\fP (const wchar_t *, const wchar_t *, size_t)"
.br
.RI "Compare wide characters in memory\&. "
.ti -1c
.RI "size_t \fB_vfprintf\fP (FILE *restrict, const char *restrict, va_list)"
.br
.RI "Write to stream char format variable argument list\&. "
.ti -1c
.RI "size_t \fB_vsnprintf\fP (char *restrict, size_t, const char *restrict, va_list)"
.br
.RI "Write formatted data from variable argument list to sized buffer\&. "
.ti -1c
.RI "size_t \fB_fprintf\fP (FILE *restrict, const char *restrict,\&.\&.\&.)"
.br
.RI "Write to stream char format variable arguments\&. "
.ti -1c
.RI "size_t \fB_printf\fP (const char *restrict fmt,\&.\&.\&.)"
.br
.RI "Write to stdout char format variable arguments\&. "
.ti -1c
.RI "size_t \fB_snprintf\fP (char *restrict, size_t, const char *restrict,\&.\&.\&.)"
.br
.RI "Format variable arguments list\&. "
.ti -1c
.RI "size_t \fB_vfwprintf\fP (FILE *restrict, const wchar_t *restrict, va_list)"
.br
.RI "Write to stream wide character format variable argument list\&. "
.ti -1c
.RI "size_t \fB_vswprintf\fP (wchar_t *restrict, size_t, const wchar_t *restrict, va_list)"
.br
.RI "Write formatted data from variable argument list to sized buffer\&. "
.ti -1c
.RI "size_t \fB_fwprintf\fP (FILE *restrict, const wchar_t *restrict,\&.\&.\&.)"
.br
.RI "Write to stream wide character format variable arguments\&. "
.ti -1c
.RI "size_t \fB_swprintf\fP (wchar_t *restrict, size_t, const wchar_t *restrict,\&.\&.\&.)"
.br
.RI "Write formatted wide character output\&. "
.ti -1c
.RI "size_t \fB_wprintf\fP (const wchar_t *restrict fmt,\&.\&.\&.)"
.br
.RI "Write a formatted wide character string to 'stdout'\&. "
.ti -1c
.RI "int \fB_fputws\fP (const wchar_t *restrict, FILE *restrict)"
.br
.RI "Write a wide character string to a file or stream\&. "
.ti -1c
.RI "wchar_t \fB_fputwc\fP (wchar_t, FILE *restrict)"
.br
.RI "Write a wide character to a file or stream\&. "
.ti -1c
.RI "size_t \fB_wcsftime\fP (wchar_t *restrict, size_t sz, const wchar_t *restrict, const void *restrict)"
.br
.RI "Convert date and time to a formatted wide-character string\&. "
.ti -1c
.RI "wchar_t * \fB_wcsptime\fP (const wchar_t *, const wchar_t *, void *)"
.br
.RI "Convert a wide-character string representation of time to a time \fCtm\fP structure\&. "
.ti -1c
.RI "FILE * \fB_wfopen\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Open the stream for the file, takes as the first parameter the file name and the second parameter the opening mode in the form of wide characters\&. "
.ti -1c
.RI "FILE * \fB_wfopen_s\fP (const wchar_t *, size_t, const wchar_t *)"
.br
.RI "The same as \fB_wfopen\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. "
.ti -1c
.RI "FILE * \fB_wfopen_ws\fP (const \fBstring_ws\fP *, const wchar_t *)"
.br
.RI "The same as \fB_wfopen\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. "
.ti -1c
.RI "FILE * \fB_wfopen_selector\fP (int, const void *, size_t, const void *)"
.br
.RI "Automatic type selector for \fCwfopen*\fP functions\&. "
.ti -1c
.RI "FILE * \fBu8wfopen\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Open file stream, after converting the file name from wide characters to UTF-8\&. "
.ti -1c
.RI "int \fB_wstat\fP (const wchar_t *, void *)"
.br
.RI "Functions \fCwstat*()\fP fill the structure with data about the file pointed to by \fCstruct stat\fP, associated with the file name\&. "
.ti -1c
.RI "int \fB_wstat_s\fP (const wchar_t *, size_t, void *)"
.br
.RI "The same as \fB_wstat\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. "
.ti -1c
.RI "int \fB_wstat_ws\fP (const \fBstring_ws\fP *, void *)"
.br
.RI "The same as \fB_wstat\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. "
.ti -1c
.RI "int \fB_wstat_selector\fP (int, const void *, size_t, const void *)"
.br
.RI "Automatic type selector for \fCwstat*\fP functions\&. "
.ti -1c
.RI "int \fBu8wstat\fP (const wchar_t *, void *)"
.br
.RI "Get file statistics by first converting the file name from wide characters to UTF-8\&. "
.ti -1c
.RI "int \fB_wrename\fP (const wchar_t *, const wchar_t *)"
.br
.RI "The \fCwrename()\fP function changes the file name to a new one\&. "
.ti -1c
.RI "int \fB_wrename_s\fP (const wchar_t *, size_t, const wchar_t *, size_t)"
.br
.RI "The same as \fB_wrename\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. "
.ti -1c
.RI "int \fB_wrename_ws\fP (const \fBstring_ws\fP *, const \fBstring_ws\fP *)"
.br
.RI "The same as \fB_wrename\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. "
.ti -1c
.RI "int \fB_wrename_selector\fP (int, const void *, size_t, const void *, size_t)"
.br
.RI "Automatic type selector for \fCwrename*\fP functions\&. "
.ti -1c
.RI "int \fBu8wrename\fP (const wchar_t *, const wchar_t *)"
.br
.RI "Rename file, after converting the file name from wide characters to UTF-8\&. "
.ti -1c
.RI "int \fB_wremove\fP (const wchar_t *)"
.br
.RI "The \fCwremove*()\fP function deletes a name from the file system\&. "
.ti -1c
.RI "int \fB_wremove_s\fP (const wchar_t *, size_t)"
.br
.RI "The same as \fB_wremove\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. "
.ti -1c
.RI "int \fB_wremove_ws\fP (const \fBstring_ws\fP *)"
.br
.RI "The same as \fB_wremove\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. "
.ti -1c
.RI "int \fB_wremove_selector\fP (int, const void *, size_t)"
.br
.RI "Automatic type selector for \fCwremove*\fP functions\&. "
.ti -1c
.RI "int \fBu8wremove\fP (const wchar_t *)"
.br
.RI "Delete (remove) file or directory, after converting the file name from wide characters to UTF-8\&. "
.ti -1c
.RI "int \fB_wmkdir\fP (const wchar_t *, mode_t)"
.br
.RI "Creates a directory or a chain of directories specified in the path\&. "
.ti -1c
.RI "int \fB_wmkdir_s\fP (const wchar_t *, size_t, mode_t)"
.br
.RI "The same as \fB_wmkdir\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. "
.ti -1c
.RI "int \fB_wmkdir_ws\fP (const \fBstring_ws\fP *, mode_t)"
.br
.RI "The same as \fB_wmkdir\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. "
.ti -1c
.RI "int \fB_wmkdir_selector\fP (int, const void *, size_t, mode_t)"
.br
.RI "Automatic type selector for \fCwmkdir*\fP functions\&. "
.ti -1c
.RI "int \fBu8wmkdir\fP (const wchar_t *, mode_t)"
.br
.RI "Creates a directory or a chain of directories specified in the path, after converting the file name from wide characters to UTF-8\&. "
.ti -1c
.RI "\fBaccess_e\fP \fB_waccess\fP (const wchar_t *, int)"
.br
.RI "Check permissions for a file or directory, wide char input\&. "
.ti -1c
.RI "\fBaccess_e\fP \fB_waccess_s\fP (const wchar_t *, size_t, int)"
.br
.RI "Check permissions for a file or directory, wide char input with size\&. "
.ti -1c
.RI "\fBaccess_e\fP \fB_waccess_ws\fP (const \fBstring_ws\fP *, int)"
.br
.RI "Check permissions for a file or directory, struct \fBstring_ws\fP input\&. "
.ti -1c
.RI "\fBaccess_e\fP \fB_waccess_selector\fP (int, const void *, size_t, int)"
.br
.RI "Automatic type selector for wmkdir* functions\&. "
.ti -1c
.RI "\fBaccess_e\fP \fBu8waccess\fP (const wchar_t *, int)"
.br
.RI "Check permissions for a file or directory, convert file name from wide characters to UTF-8\&. "
.ti -1c
.RI "wchar_t * \fB_wbasename\fP (const wchar_t *)"
.br
.RI "Parse path file name, wide char input\&. "
.ti -1c
.RI "wchar_t * \fB_wbasename_ws\fP (const \fBstring_ws\fP *)"
.br
.RI "Parse path file name, struct \fBstring_ws\fP input\&. "
.ti -1c
.RI "void * \fB_wbasename_selector\fP (int, const void *)"
.br
.RI "Automatic type selector for wbasename* functions\&. "
.ti -1c
.RI "wchar_t * \fB_wbaseext\fP (const wchar_t *)"
.br
.RI "Parse path extension, wide char input\&. "
.ti -1c
.RI "wchar_t * \fB_wbaseext_ws\fP (const \fBstring_ws\fP *)"
.br
.RI "Parse path extension, struct \fBstring_ws\fP input\&. "
.ti -1c
.RI "void * \fB_wbaseext_selector\fP (int, const void *)"
.br
.RI "Automatic type selector for wbaseext* functions\&. "
.ti -1c
.RI "wchar_t * \fB_wbasedir\fP (const wchar_t *, int)"
.br
.RI "Parse path directory + normalize slash from path, wide char input\&. "
.ti -1c
.RI "wchar_t * \fB_wbasedir_ws\fP (const \fBstring_ws\fP *, int)"
.br
.RI "Parse path directory + normalize slash from path, struct \fBstring_ws\fP input\&. "
.ti -1c
.RI "void * \fB_wbasedir_selector\fP (int, const void *, int)"
.br
.RI "Automatic type selector for wbasedir* functions\&. "
.ti -1c
.RI "wchar_t * \fB_wpathnormalize\fP (const wchar_t *, int)"
.br
.RI "Normalize slash from path, wide char input, int is string size, default 0\&. "
.ti -1c
.RI "wchar_t * \fB_wpathnormalize_ws\fP (const \fBstring_ws\fP *)"
.br
.RI "Normalize slash from path, struct \fBstring_ws\fP input\&. "
.ti -1c
.RI "char * \fBu8wpathnormalize\fP (const wchar_t *)"
.br
.RI "Normalize slash from path, convert file name from wide characters to UTF-8\&. "
.ti -1c
.RI "void \fBwstring_free\fP (\fBstring_ws\fP *restrict)"
.br
.RI "Memory free string, empty and clear struct \fBstring_ws\fP\&. "
.ti -1c
.RI "size_t \fBwstring_alloc\fP (\fBstring_ws\fP *restrict, size_t)"
.br
.RI "Memory allocation string, struct string_ws->str output\&. "
.ti -1c
.RI "char * \fBwstring_wstocs_alloc\fP (const wchar_t *restrict)"
.br
.RI "Converting string, wchar_t input, char allocate output\&. "
.ti -1c
.RI "char * \fBwstring_swstocs_alloc\fP (const \fBstring_ws\fP *restrict)"
.br
.RI "Converting string, \fBstring_ws\fP input, char allocate output\&. "
.ti -1c
.RI "wchar_t * \fBwstring_cstows_alloc\fP (const char *restrict)"
.br
.RI "Converting string, char input, wchar_t allocate output\&. "
.ti -1c
.RI "size_t \fBwstring_cstows_ws_alloc\fP (\fBstring_ws\fP *restrict, const char *restrict)"
.br
.RI "Converting string, \fBstring_ws\fP input, length output\&. "
.ti -1c
.RI "size_t \fBwstring_format\fP (\fBstring_ws\fP *, const wchar_t *restrict,\&.\&.\&.)"
.br
.RI "Append string, format \fCvargs\fP support input, \fCstruct \fBstring_ws\fP\fP output\&. "
.ti -1c
.RI "size_t \fBwstring_append\fP (\fBstring_ws\fP *, const wchar_t *restrict, size_t)"
.br
.RI "Append string: \fCwchar_t*\fP, lenght input, \fCstruct \fBstring_ws\fP\fP output\&. "
.ti -1c
.RI "size_t \fBwstring_appends_\fP (\fBstring_ws\fP *,\&.\&.\&.)"
.br
.RI "Append strings, only \fCwchar_t*\fP strings args inputs, \fCstruct \fBstring_ws\fP\fP output\&. "
.ti -1c
.RI "size_t \fBwstring_append_cvt\fP (\fBstring_ws\fP *, const char *restrict, size_t)"
.br
.RI "Append string: source type \fCchar*\fP, lenght input, \fCstruct \fBstring_ws\fP\fP output\&. "
.ti -1c
.RI "size_t \fBwstring_cstows\fP (wchar_t [], size_t, const char *restrict, size_t)"
.br
.RI "Converting string, char input, wchar_t array output, to alloc buffer write\&. "
.ti -1c
.RI "size_t \fBwstring_wstocs\fP (char [], size_t, const wchar_t *restrict, size_t)"
.br
.RI "Converting string, struct wchar_t input, char array output, to alloc buffer write\&. "
.ti -1c
.RI "size_t \fBwstring_wstocs_ws\fP (char [], size_t, const \fBstring_ws\fP *restrict)"
.br
.RI "Converting string, struct \fBstring_ws\fP input, char array output, to alloc buffer write\&. "
.ti -1c
.RI "wchar_t * \fBwstring_timeformat\fP (const wchar_t *restrict, size_t, const wchar_t *restrict, const wchar_t *restrict)"
.br
.RI "Converting time format string to string, wchar_t and size_t input\&. "
.ti -1c
.RI "wchar_t * \fBwstring_timeformat_ws\fP (const \fBstring_ws\fP *restrict, const wchar_t *restrict, const wchar_t *restrict)"
.br
.RI "Converting time format string to string, \fBstring_ws\fP input\&. "
.ti -1c
.RI "int \fBwstring_isempty\fP (const wchar_t *restrict s, int)"
.br
.RI "Check wchar_t input string is empty, bool return\&. "
.ti -1c
.RI "\fBstring_ws\fP \fBwstring_trunc\fP (const wchar_t *ws, int)"
.br
.RI "Truncation string, wchar_t input, struct \fBstring_ws\fP return\&. "
.ti -1c
.RI "size_t \fBwstring_trunc_alloc\fP (\fBstring_ws\fP *restrict, const wchar_t *, int)"
.br
.RI "Truncation string, wchar_t input, return pointer to struct \fBstring_ws\fP and lenght\&. "
.ti -1c
.RI "int \fB_wclosedir\fP (\fBWDIR_t\fP *)"
.br
.RI "Closes the directory stream\&. "
.ti -1c
.RI "\fBWDIR_t\fP * \fB_wopendir\fP (const wchar_t *)"
.br
.RI "Opens a directory stream and returns a pointer to the stream\&. The stream is set to the first entry in the directory\&. "
.ti -1c
.RI "\fBwdirent_t\fP * \fB_wreaddir\fP (\fBWDIR_t\fP *)"
.br
.RI "Reads the directory stream\&. "
.ti -1c
.RI "int \fB_wreaddir_r\fP (\fBWDIR_t\fP *, \fBwdirent_t\fP *, \fBwdirent_t\fP **)"
.br
.RI "Reads the directory stream extended\&. "
.ti -1c
.RI "int \fB_wreaddir_cb\fP (wchar_t *, long, \fBwdir_cb\fP, void *)"
.br
.RI "Reads the directory stream callBack\&. "
.ti -1c
.RI "void \fB_wrewinddir\fP (\fBWDIR_t\fP *)"
.br
.RI "Sets the beginning in the directory stream\&. "
.ti -1c
.RI "void \fB_wseekdir\fP (\fBWDIR_t\fP *, long int)"
.br
.RI "Sets the position in the directory stream\&. "
.ti -1c
.RI "long int \fB_wtelldir\fP (\fBWDIR_t\fP *)"
.br
.RI "Returns the current position of the directory stream\&. "
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct string_ws"
.PP 
Base wide string structure\&. 
.PP
\fBData Fields:\fP
.RS 4
wchar_t * \fIstr\fP wide string pointer 
.br
.PP
size_t \fIsz\fP size wide string 
.br
.PP
.RE
.PP
.SH "struct _wdirent"
.PP 
the contains constructs that facilitate directory traversing 
.PP
\fBData Fields:\fP
.RS 4
unsigned int \fId_ino\fP Inode number\&. 
.br
.PP
wchar_t \fId_name[256]\fP Null-terminated filename\&. 
.br
.PP
long int \fId_off\fP Offset\&. 
.br
.PP
unsigned short \fId_reclen\fP Length of this record\&. 
.br
.PP
unsigned char \fId_type\fP Type of file\&. 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define USED_WCHAR2LIB   1"

.PP
Define this flag for other software, indicate enable \fClibwchar2\fP in you project\&. flag indicate enable libwchar2 
.SS "#define wreaddir_cb_opt(opt, val)   ((opt) | (1L << (val)))"

.PP
Macro to set options value to function \fB_wreaddir_cb\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP - \fClong int\fP options variable 
.br
\fIval\fP - option value, valid \fCDIRENTRYSIZE\fP, \fCDIRNOROOT\fP, \fCDIRNODIR\fP
.RE
.PP
\fBsupport:\fP \fCALL\fP 
.SS "#define wstocscvt(A, B, D)"
\fBValue:\fP
.PP
.nf
size_t __WEV(sz,__LINE__); errno = 0;                                                                          \
    if ((__WEV(sz,__LINE__) = _wcsrtombs(NULL, &(const wchar_t*){B}, 0, 0)) <= 0) {                                \
        errno = EILSEQ; return D;                                                                                  \
    }                                                                                                              \
    char __WEV(A,__LINE__)[(__WEV(sz,__LINE__) + 1)], * A = (char*)&__WEV(A,__LINE__);                             \
    if ((__WEV(sz,__LINE__) = _wcsrtombs(__WEV(A,__LINE__), &(const wchar_t*){B}, (__WEV(sz,__LINE__) + 1), 0))) { \
        __WEV(A,__LINE__)[(__WEV(sz,__LINE__))] = '\0';                                                            \
    }
.fi
.PP
wchar_t* type to char[] A char[] - array name B wchar_t* - source D - function return value if error Other non standart macro 
.br

.br

.SS "#define wstocsncvt(A, B, C, D)"
\fBValue:\fP
.PP
.nf
char __WEV(A,__LINE__)[(C + 1 * sizeof(wchar_t))], * A = (char*)&__WEV(A,__LINE__); errno = 0;                  \
    if (((C) = _wcsrtombs(__WEV(A,__LINE__), &(const wchar_t*){B}, (C * 2 + 1), 0)) <= 0) {                         \
        errno = EILSEQ; return D;                                                                                   \
    }                                                                                                               \
    __WEV(A,__LINE__)[(C)] = '\0'
.fi
.PP
wchar_t* type to char[] with size A char[] - array name B wchar_t* - source C size_t - wchar_t* size D - function return value if error 
.SS "#define wstrtocscvt(A, B, D)"
\fBValue:\fP
.PP
.nf
size_t __WEV(sz,__LINE__); errno = 0;                                                                           \
    char __WEV(A,__LINE__)[(B->sz + 1 * sizeof(wchar_t))], * A = (char*)&__WEV(A,__LINE__);                         \
    if ((__WEV(sz,__LINE__) = _wcsrtombs(__WEV(A,__LINE__), &(const wchar_t*){B->str}, (B->sz * 2 + 1), 0)) <= 0) { \
        errno = EILSEQ; return D;                                                                                   \
    }                                                                                                               \
    __WEV(A,__LINE__)[__WEV(sz,__LINE__)] = '\0'
.fi
.PP
\fBstring_ws\fP type to char[] this struct defined on top of this file A char[] - array name B string_ws* - source D - function return value if error 
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* wdir_cb) (unsigned int, \fBaccess_e\fP, long long, \fBstring_ws\fP *, void *)"

.PP
CallBack for \fB_wreaddir_cb\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI<tt>long</tt>\fP - counter 
.br
\fI<tt>access_e</tt>\fP - type of entry 
.br
\fI<tt>long\fP long - size of entry 
.br
\fI<tt>string_ws</tt>\fP - entry name (file/directory name) 
.br
\fI<tt>void</tt>\fP - user data 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBaccess_e\fP"

.PP
enumeration for return waccess function 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIISERR \fP\fP
Error check\&. 
.TP
\fB\fIISUNK \fP\fP
is a Unknown 
.TP
\fB\fIISFIL \fP\fP
is a Regular file 
.TP
\fB\fIISLNK \fP\fP
is a Symbolic link 
.TP
\fB\fIISDIR \fP\fP
is a Directory 
.TP
\fB\fIISCHR \fP\fP
is a character device 
.TP
\fB\fIISBLK \fP\fP
is a block device 
.TP
\fB\fIISSOCK \fP\fP
is a UNIX domain socket 
.TP
\fB\fIISFIFO \fP\fP
is a named pipe 
.TP
\fB\fIISWHT \fP\fP
is a whiteout" from BSD 
.TP
\fB\fIDIRNODIR \fP\fP
options for read derrictory - no print dir 
.TP
\fB\fIDIRNOROOT \fP\fP
options for read derrictory - no print root parent `\&. \fCor\fP\&.\&.` dir 
.TP
\fB\fIDIRENTRYSIZE \fP\fP
options for read derrictory - get files size 
.SH "Function Documentation"
.PP 
.SS "wchar_t _btowc (int)"

.PP
Convert single byte character to wide character\&. 
.IP "\(bu" 2
\fBbtowc manual\fP 
.PP

.SS "wchar_t _fputwc (wchar_t, FILE * restrict)"

.PP
Write a wide character to a file or stream\&. 
.IP "\(bu" 2
\fBfputwc\fP 
.PP

.SS "int _fputws (const wchar_t * restrict, FILE * restrict)"

.PP
Write a wide character string to a file or stream\&. 
.IP "\(bu" 2
\fBfputws\fP 
.PP

.SS "size_t _fwprintf (FILE * restrict, const wchar_t * restrict,  \&.\&.\&.)"

.PP
Write to stream wide character format variable arguments\&. 
.IP "\(bu" 2
\fBwprintf manual\fP 
.PP

.SS "int _iswalnum (wchar_t)"

.PP
Test for alphanumeric wide character, alphabetic wide character predicate\&. 
.IP "\(bu" 2
\fBiswalnum manual\fP 
.PP

.SS "int _iswalpha (wchar_t)"

.PP
Test for whitespace wide character, alphabetic wide character predicate\&. 
.IP "\(bu" 2
\fBiswalpha manual\fP 
.PP

.SS "int _iswblank (wchar_t)"

.PP
Test for whitespace wide character\&. 
.IP "\(bu" 2
\fBiswblank manual\fP 
.PP

.SS "int _iswcntrl (wchar_t)"

.PP
Test for control wide character\&. 
.IP "\(bu" 2
\fBiswcntrl manual\fP 
.PP

.SS "int _iswctype (wchar_t, wctype_t)"

.PP
Extensible wide-character test, wide-character classification\&. 
.IP "\(bu" 2
\fBiswctype manual\fP 
.PP

.SS "int _iswdigit (wchar_t)"

.PP
Test for decimal digit wide character\&. 
.IP "\(bu" 2
\fBiswdigit manual\fP 
.PP

.SS "int _iswgraph (wchar_t)"

.PP
Test for graphic wide character\&. 
.IP "\(bu" 2
\fBiswgraph manual\fP 
.PP

.SS "int _iswlower (wchar_t)"

.PP
Ttest for lowercase wide character\&. 
.IP "\(bu" 2
\fBiswlower manual\fP 
.PP

.SS "int _iswprint (wchar_t)"

.PP
Test for printing wide character\&. 
.IP "\(bu" 2
\fBiswprint manual\fP 
.PP

.SS "int _iswpunct (wchar_t)"

.PP
Test for punctuation or symbolic wide character\&. 
.IP "\(bu" 2
\fBiswpunct manual\fP 
.PP

.SS "int _iswspace (wchar_t)"

.PP
Test for whitespace wide character\&. 
.IP "\(bu" 2
\fBiswspace manual\fP 
.PP

.SS "int _iswupper (wchar_t)"

.PP
Test for uppercase wide character\&. 
.IP "\(bu" 2
\fBiswupper manual\fP 
.PP

.SS "int _iswxdigit (wchar_t)"

.PP
Test for hexadecimal digit wide character\&. 
.IP "\(bu" 2
\fBiswxdigit manual\fP 
.PP

.SS "int _mblen (const char *, size_t)"

.PP
Determines the size, in bytes, of the multibyte character whose first byte is pointed\&. 
.IP "\(bu" 2
\fBmblen manual\fP 
.PP

.SS "size_t _mbrlen (const char * restrict, size_t, mbstate_t * restrict)"

.PP
Get length of multibyte character\&. 
.IP "\(bu" 2
\fBmbrlen manual\fP 
.PP

.SS "size_t _mbrtowc (wchar_t * restrict, const char *restrict src, size_t, mbstate_t * restrict)"

.PP
Converts a narrow multibyte character to a wide character\&. 
.IP "\(bu" 2
\fBmbrtowc manual\fP 
.PP

.SS "int _mbsinit (const mbstate_t *)"

.PP
Check if initial conversion state\&. 
.IP "\(bu" 2
\fBmbsinit manual\fP 
.PP

.SS "size_t _mbsnrtowcs (wchar_t * restrict, const char ** restrict, size_t, size_t, mbstate_t * restrict)"

.PP
Convert a character string to a wide-character string\&. 
.IP "\(bu" 2
\fBmbsnrtowcs manual\fP 
.PP

.SS "size_t _mbsrtowcs (wchar_t * restrict, const char ** restrict, size_t, mbstate_t * restrict)"

.PP
Convert a character string to a wide-character string\&. 
.IP "\(bu" 2
\fBmbsrtowcs manual\fP 
.PP

.SS "size_t _mbstowcs (wchar_t * restrict, const char * restrict, size_t)"

.PP
Minimal multibyte string to wide string converter\&. 
.IP "\(bu" 2
\fBmbstowcs manual\fP 
.PP

.SS "int _mbtowc (wchar_t * restrict, const char * restrict, size_t)"

.PP
Minimal multibyte to wide char converter\&. 
.IP "\(bu" 2
\fBmbtowc manual\fP 
.PP

.SS "size_t _swprintf (wchar_t * restrict, size_t, const wchar_t * restrict,  \&.\&.\&.)"

.PP
Write formatted wide character output\&. 
.IP "\(bu" 2
\fBwprintf manual\fP 
.PP

.SS "wchar_t _towctrans (wchar_t, wctrans_t)"

.PP
Extensible wide-character translation\&. 
.IP "\(bu" 2
\fBtowctrans manual\fP 
.PP

.SS "wchar_t _towlower (wchar_t)"

.PP
Translate wide characters to lowercase\&. 
.IP "\(bu" 2
\fBtowlower manual\fP 
.PP

.SS "wchar_t _towupper (wchar_t)"

.PP
Translate wide characters to uppercase\&. 
.IP "\(bu" 2
\fBtowupper manual\fP 
.PP

.SS "size_t _vfwprintf (FILE * restrict, const wchar_t * restrict, va_list)"

.PP
Write to stream wide character format variable argument list\&. 
.IP "\(bu" 2
\fBwprintf manual\fP 
.PP

.SS "size_t _vswprintf (wchar_t * restrict, size_t, const wchar_t * restrict, va_list)"

.PP
Write formatted data from variable argument list to sized buffer\&. 
.IP "\(bu" 2
\fBwprintf manual\fP 
.PP

.SS "\fBaccess_e\fP _waccess (const wchar_t *, int)"

.PP
Check permissions for a file or directory, wide char input\&. 
.PP
\fBNote:\fP
.RS 4
All waccess* function return extended status, see access_e enum value, if error return standart -1
.RE
.PP
.IP "\(bu" 2
\fBwaccess manual\fP 
.PP

.SS "wchar_t* _wbasedir (const wchar_t *, int)"

.PP
Parse path directory + normalize slash from path, wide char input\&. 
.PP
\fBNote:\fP
.RS 4
If Success return substring of path, else return NULL 
.RE
.PP
\fBAttention:\fP
.RS 4
all functions _wbasedir* requires to free the returned result, use type __WSTRFREE for auto free 
.RE
.PP

.SS "wchar_t* _wbaseext (const wchar_t *)"

.PP
Parse path extension, wide char input\&. 
.PP
\fBNote:\fP
.RS 4
If Success return substring of path, else return NULL 
.RE
.PP

.SS "wchar_t* _wbasename (const wchar_t *)"

.PP
Parse path file name, wide char input\&. 
.PP
\fBNote:\fP
.RS 4
If Success return substring of path, else return NULL 
.RE
.PP

.SS "int _wclosedir (\fBWDIR_t\fP *)"

.PP
Closes the directory stream\&. The \fCwclosedir()\fP function closes the directory stream\&. If the function is successfully called, the file descriptor associated with the directory is also closed\&. The descriptor of the directory stream opened in the past will be unavailable after this call\&.
.PP
\fBsupport:\fP \fCLINUX\fP, \fCMSVC/MSVS\fP, \fCMinGW\fP - default include 
.SS "wchar_t* _wcpcpy (wchar_t *, const wchar_t *)"

.PP
Copy a wide-character string returning a pointer to its end\&. 
.IP "\(bu" 2
\fBwcpcpy manual\fP 
.PP

.SS "wchar_t* _wcpncpy (wchar_t *, const wchar_t *, size_t)"

.PP
Copy part of a wide-character string returning a pointer to its end\&. 
.IP "\(bu" 2
\fBwcpncpy manual\fP 
.PP

.SS "size_t _wcrtomb (char * restrict, wchar_t, mbstate_t * restrict)"

.PP
Convert wide character to multibyte sequence\&. 
.IP "\(bu" 2
\fBwcrtomb manual\fP 
.PP

.SS "int _wcscasecmp (const wchar_t *, const wchar_t *)"

.PP
Case-insensitive wide character string compare\&. 
.IP "\(bu" 2
\fBwcscasecmp manual\fP 
.PP

.SS "wchar_t* _wcscat (wchar_t *, const wchar_t *)"

.PP
Concatenate wide-character strings\&. 
.IP "\(bu" 2
\fBwcscat manual\fP 
.PP

.SS "wchar_t* _wcschr (const wchar_t *, wchar_t)"

.PP
Search for wide character in string\&. 
.IP "\(bu" 2
\fBwcschr manual\fP 
.PP

.SS "int _wcscmp (const wchar_t *, const wchar_t *)"

.PP
Wide-character string compare\&. 
.IP "\(bu" 2
\fBwcscmp manual\fP 
.PP

.SS "size_t _wcsftime (wchar_t * restrict, size_t sz, const wchar_t * restrict, const void * restrict)"

.PP
Convert date and time to a formatted wide-character string\&. The original version of the \fCstrftime()\fP function is used for the conversion\&. The \fCwcsftime()\fP function converts the results from wide characters to a multibyte string and back\&.
.PP
.IP "\(bu" 2
\fBwcsftime manual\fP
.IP "\(bu" 2
\fB_wcsptime\fP related \fB_wcsftime\fP 
.PP

.SS "size_t _wcslen (const wchar_t *)"

.PP
Wide-character string length\&. 
.IP "\(bu" 2
\fBwcslen manual\fP 
.PP

.SS "int _wcsncasecmp (const wchar_t *, const wchar_t *, size_t)"

.PP
Case-insensitive wide character string compare with size\&. 
.IP "\(bu" 2
\fBwcsncasecmp manual\fP 
.PP

.SS "wchar_t* _wcsncat (wchar_t *, const wchar_t *, size_t)"

.PP
Concatenate wide-character strings with size\&. 
.IP "\(bu" 2
\fBwcsncat manual\fP 
.PP

.SS "int _wcsncmp (const wchar_t *, const wchar_t *, size_t)"

.PP
Wide-character string compare\&. Wide-character string compare
.PP
.IP "\(bu" 2
\fBwcsncmp manual\fP 
.PP

.SS "wchar_t* _wcsncpy (wchar_t *, const wchar_t *, size_t)"

.PP
Counted copy wide-character string\&. 
.IP "\(bu" 2
\fBwcsncpy manual\fP 
.PP

.SS "size_t _wcsnlen (const wchar_t *, size_t)"

.PP
Wide-character string length with maximum limit\&. 
.IP "\(bu" 2
\fBwcsnlen manual\fP 
.PP

.SS "size_t _wcsnrtombs (char * restrict, const wchar_t ** restrict, size_t, size_t, mbstate_t * restrict)"

.PP
Convert a wide-character string to a character string\&. 
.IP "\(bu" 2
\fBwcsnrtombs manual\fP 
.PP

.SS "wchar_t* _wcspbrk (const wchar_t *, const wchar_t *)"

.PP
Find wide characters in string\&. 
.IP "\(bu" 2
\fBwcspbrk manual\fP 
.PP

.SS "wchar_t* _wcsptime (const wchar_t *, const wchar_t *, void *)"

.PP
Convert a wide-character string representation of time to a time \fCtm\fP structure\&. The function \fCwcsptime()\fP is equivalent to the function \fCstrptime()\fP\&. The \fCwcsptime()\fP function converts a wide character string into a \fCtm\fP structure format, according to the format specified in the parameters\&.
.PP
.IP "\(bu" 2
\fBwcsptime manual\fP
.IP "\(bu" 2
\fB_wcsptime\fP related \fB_wcsftime\fP 
.PP

.SS "wchar_t* _wcsrchr (const wchar_t *, wchar_t)"

.PP
Reverse search for wide character in string\&. 
.IP "\(bu" 2
\fBwcsrchr manual\fP 
.PP

.SS "size_t _wcsrtombs (char * restrict, const wchar_t ** restrict, size_t, mbstate_t * restrict)"

.PP
Convert a wide-character string to a character string\&. 
.IP "\(bu" 2
\fBwcsrtombs manual\fP 
.PP

.SS "size_t _wcsspn (const wchar_t *, const wchar_t *)"

.PP
Find initial match in wide-character string\&. Find initial match in wide-character string
.PP
.IP "\(bu" 2
\fBwcsspn manual\fP 
.PP

.SS "wchar_t* _wcsstr (const wchar_t *, const wchar_t *)"

.PP
Find wide-character string segment\&. 
.IP "\(bu" 2
\fBwcsstr manual\fP 
.PP

.SS "double _wcstod (const wchar_t *, wchar_t **)"

.PP
Convert wide character ASCII string to \fCdouble\fP number\&. 
.IP "\(bu" 2
\fBwcstod manual\fP 
.PP

.SS "float _wcstof (const wchar_t *, wchar_t **)"

.PP
Convert wide character ASCII string to \fCfloat\fP number\&. 
.IP "\(bu" 2
\fBwcstof manual\fP 
.PP

.SS "intmax_t _wcstoimax (const wchar_t *, wchar_t **, int)"

.PP
Convert wide character ASCII string to \fCintmax_t\fP integer\&. 
.IP "\(bu" 2
\fBwcstoimax manual\fP 
.PP

.SS "wchar_t* _wcstok (wchar_t *, const wchar_t *, wchar_t **)"

.PP
Tokenize wide-character string\&. 
.IP "\(bu" 2
\fBwcstok manual\fP 
.PP

.SS "long int _wcstol (const wchar_t *, wchar_t **, int)"

.PP
Convert wide character ASCII string to \fClong int\fP number\&. 
.IP "\(bu" 2
\fBwcstol manual\fP 
.PP

.SS "long double _wcstold (const wchar_t *, wchar_t **)"

.PP
Convert wide character ASCII string to \fClong double\fP number\&. 
.IP "\(bu" 2
\fBwcstold manual\fP 
.PP

.SS "long long int _wcstoll (const wchar_t *, wchar_t **, int)"

.PP
Convert wide character ASCII string to \fClong long int\fP number\&. 
.IP "\(bu" 2
\fBwcstoll manual\fP 
.PP

.SS "size_t _wcstombs (char * restrict, const wchar_t * restrict, size_t)"

.PP
Minimal wide string to multibyte string converter\&. 
.IP "\(bu" 2
\fBwcstombs manual\fP 
.PP

.SS "size_t _wcstombs_s (char * restrict, const wchar_t * restrict, size_t)"

.PP
Minimal wide string to multibyte string converter + double size out buffer\&. 
.IP "\(bu" 2
\fBwcstombs manual\fP 
.PP

.SS "unsigned long int _wcstoul (const wchar_t *, wchar_t **, int)"

.PP
Convert wide character ASCII string to \fCunsigned long int\fP number\&. 
.IP "\(bu" 2
\fBwcstoul manual\fP 
.PP

.SS "unsigned long long int _wcstoull (const wchar_t *, wchar_t **, int)"

.PP
Convert wide character ASCII string to \fCunsigned long long int\fP number\&. 
.IP "\(bu" 2
\fBwcstoull manual\fP 
.PP

.SS "uintmax_t _wcstoumax (const wchar_t *, wchar_t **, int)"

.PP
Convert wide character ASCII string to \fCuintmax_t\fP integer\&. 
.IP "\(bu" 2
\fBwcstoumax manual\fP 
.PP

.SS "int _wcswidth (const wchar_t *, size_t)"

.PP
Number of column positions of a wide-character string\&. 
.IP "\(bu" 2
\fBwcswidth manual\fP 
.PP

.SS "int _wctob (wchar_t)"

.PP
Convert wide character to single byte\&. 
.IP "\(bu" 2
\fBwctob manual\fP 
.PP

.SS "int _wctomb (char *, wchar_t)"

.PP
Minimal wide char to multibyte converter\&. 
.IP "\(bu" 2
\fBwctomb manual\fP 
.PP

.SS "wctrans_t _wctrans (const char *)"

.PP
Compute wide-character translation type\&. 
.IP "\(bu" 2
\fBwctrans\fP 
.PP

.SS "wctype_t _wctype (const char *)"

.PP
Compute wide-character test type\&. 
.IP "\(bu" 2
\fBwctype manual\fP 
.PP

.SS "int _wcwidth (wchar_t)"

.PP
Number of column positions of a wide-character code\&. 
.IP "\(bu" 2
\fBwcwidth manual\fP 
.PP

.SS "FILE* _wfopen (const wchar_t *, const wchar_t *)"

.PP
Open the stream for the file, takes as the first parameter the file name and the second parameter the opening mode in the form of wide characters\&. 
.IP "\(bu" 2
\fBwfopen manual\fP 
.PP

.SS "FILE* _wfopen_s (const wchar_t *, size_t, const wchar_t *)"

.PP
The same as \fB_wfopen\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. 
.IP "\(bu" 2
\fBwfopen manual\fP 
.PP

.SS "FILE* _wfopen_selector (int, const void *, size_t, const void *)"

.PP
Automatic type selector for \fCwfopen*\fP functions\&. 
.IP "\(bu" 2
\fBwfopen manual\fP 
.PP

.SS "FILE* _wfopen_ws (const \fBstring_ws\fP *, const wchar_t *)"

.PP
The same as \fB_wfopen\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. 
.IP "\(bu" 2
\fBwfopen manual\fP 
.PP

.SS "wchar_t* _wmemchr (const wchar_t *, wchar_t, size_t)"

.PP
Find wide character in memory\&. 
.IP "\(bu" 2
\fBwmemchr manual\fP 
.PP

.SS "int _wmemcmp (const wchar_t *, const wchar_t *, size_t)"

.PP
Compare wide characters in memory\&. 
.IP "\(bu" 2
\fBwmemcmp manual\fP 
.PP

.SS "wchar_t* _wmemcpy (wchar_t *, const wchar_t *, size_t)"

.PP
Copy wide characters in memory\&. 
.IP "\(bu" 2
\fBwmemcpy manual\fP 
.PP

.SS "wchar_t* _wmemmove (wchar_t *, const wchar_t *, size_t)"

.PP
Copy wide characters in memory with overlapping areas\&. 
.IP "\(bu" 2
\fBwmemmove manual\fP 
.PP

.SS "wchar_t* _wmemset (wchar_t *, wchar_t, size_t)"

.PP
Set wide characters in memory\&. 
.IP "\(bu" 2
\fBwmemset manual\fP 
.PP

.SS "int _wmkdir (const wchar_t *, mode_t)"

.PP
Creates a directory or a chain of directories specified in the path\&. 
.PP
\fBNote:\fP
.RS 4
The equivalent of using the \fCmkdir\fP command with the \fC-p\fP switch for all functions \fCwmkdir*()\fP If the internal flag \fCEXIST\fP is received while creating the directory, the function continues execution, if this is the last one from the list of created directories, it returns \fC0\fP\&. In other cases, returns a standard response as a function of \fCmkdir()\fP\&. If the directory exists from the specified path, the function continues execution, proceeding to create the next directory\&.
.RE
.PP
.IP "\(bu" 2
\fBwmkdir manual\fP 
.PP

.SS "int _wmkdir_s (const wchar_t *, size_t, mode_t)"

.PP
The same as \fB_wmkdir\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. 
.IP "\(bu" 2
\fBwmkdir manual\fP 
.PP

.SS "int _wmkdir_selector (int, const void *, size_t, mode_t)"

.PP
Automatic type selector for \fCwmkdir*\fP functions\&. 
.IP "\(bu" 2
\fBwmkdir manual\fP 
.PP

.SS "int _wmkdir_ws (const \fBstring_ws\fP *, mode_t)"

.PP
The same as \fB_wmkdir\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. 
.IP "\(bu" 2
\fBwmkdir manual\fP 
.PP

.SS "\fBWDIR_t\fP* _wopendir (const wchar_t *)"

.PP
Opens a directory stream and returns a pointer to the stream\&. The stream is set to the first entry in the directory\&. After a successful call, the file descriptor of the open directory is used only within the implementation and should not be used in the application\&. The function sets the \fCclose-on-exec\fP flag for the file descriptor that points to the directory\&.
.PP
\fBsupport:\fP \fCLINUX\fP, \fCMSVC/MSVS\fP, \fCMinGW\fP - default include 
.SS "wchar_t* _wpathnormalize (const wchar_t *, int)"

.PP
Normalize slash from path, wide char input, int is string size, default 0\&. 
.PP
\fBNote:\fP
.RS 4
If Success return modified path, else return NULL 
.RE
.PP
\fBAttention:\fP
.RS 4
all functions _wpathnormalize* requires to free the returned result, use type __WSTRFREE for auto free 
.RE
.PP

.SS "size_t _wprintf (const wchar_t *restrict fmt,  \&.\&.\&.)"

.PP
Write a formatted wide character string to 'stdout'\&. 
.IP "\(bu" 2
\fBwprintf manual\fP 
.PP

.SS "\fBwdirent_t\fP* _wreaddir (\fBWDIR_t\fP *)"

.PP
Reads the directory stream\&. It reads the directory stream, returns a pointer to the \fCwdirent_t\fP structure, which represents the next element in the catalog stream\&. The function returns \fCNULL\fP when the last record in the directory stream is reached or if an error occurred\&.
.PP
\fBsupport:\fP \fCLINUX\fP, \fCMSVC/MSVS\fP, \fCMinGW\fP - default include 
.SS "int _wreaddir_cb (wchar_t *, long, \fBwdir_cb\fP, void *)"

.PP
Reads the directory stream callBack\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwchar_t\fP - directory path 
.br
\fIlong\fP - options, valid \fCDIRENTRYSIZE\fP, \fCDIRNOROOT\fP, \fCDIRNODIR\fP bit mask set 
.br
\fIwdir_cb\fP - callback function 
.br
\fIvoid\fP - user data
.RE
.PP
\fBsupport:\fP \fCALL\fP
.PP
\fBtable\fP flags compatible:
.PP
FLAGS  GNU  MinGW  MSVC/MSVS  Description
.IP "\(bu" 2

.PP
DIRENTRYSIZE  x  Always  Always  Calculate size of entry   DIRNOROOT  x  x  x  Skip root directory \fC\&.\fP and \fC\&.\&.\fP   DIRNODIR  x  x  x  Skip all directory   
.SS "int _wreaddir_r (\fBWDIR_t\fP *, \fBwdirent_t\fP *, \fBwdirent_t\fP **)"

.PP
Reads the directory stream extended\&. The function \fCwreaddir_r()\fP is a reentrant version\&. It reads the next entry from the open catalog stream and returns it in the created call buffer pointed to by the second parameter of the function\&. The pointer to the returned element is placed in the third parameter of the function, if the end of the directory stream is reached, \fCNULL\fP is returned instead of the value\&.
.PP
\fBsupport:\fP \fCLINUX\fP, \fCMSVC/MSVS\fP, \fCMinGW\fP - default include 
.SS "int _wremove (const wchar_t *)"

.PP
The \fCwremove*()\fP function deletes a name from the file system\&. 
.PP
\fBReturns:\fP
.RS 4
If the file was safely deleted, \fC0\fP is returned, in the event of a \fC-1\fP error\&. On error, \fCerrno\fP is set to: \fCENOENT\fP - the file does not exist, or in \fCEACESS\fP - access is denied\&.
.RE
.PP
.IP "\(bu" 2
\fBwremove manual\fP 
.PP

.SS "int _wremove_s (const wchar_t *, size_t)"

.PP
The same as \fB_wremove\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. 
.IP "\(bu" 2
\fBwremove manual\fP 
.PP

.SS "int _wremove_selector (int, const void *, size_t)"

.PP
Automatic type selector for \fCwremove*\fP functions\&. 
.IP "\(bu" 2
\fBwremove manual\fP 
.PP

.SS "int _wremove_ws (const \fBstring_ws\fP *)"

.PP
The same as \fB_wremove\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. 
.IP "\(bu" 2
\fBwremove manual\fP 
.PP

.SS "int _wrename (const wchar_t *, const wchar_t *)"

.PP
The \fCwrename()\fP function changes the file name to a new one\&. The \fCwrename*()\fP function changes the name or location of the file, returns a standard response as a function of \fCrename()\fP\&. The new name must not be the same as the names in the directory\&.
.PP
\fBReturns:\fP
.RS 4
The function \fCwrename()\fP returns \fC0\fP in case of success and a nonzero value in case of an error\&. On error, \fCerrno\fP is set, indicating an error\&.
.RE
.PP
.IP "\(bu" 2
\fBwrename manual\fP 
.PP

.SS "int _wrename_s (const wchar_t *, size_t, const wchar_t *, size_t)"

.PP
The same as \fB_wrename\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. 
.IP "\(bu" 2
\fBwrename manual\fP 
.PP

.SS "int _wrename_selector (int, const void *, size_t, const void *, size_t)"

.PP
Automatic type selector for \fCwrename*\fP functions\&. 
.IP "\(bu" 2
\fBwrename manual\fP 
.PP

.SS "int _wrename_ws (const \fBstring_ws\fP *, const \fBstring_ws\fP *)"

.PP
The same as \fB_wrename\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. 
.IP "\(bu" 2
\fBwrename manual\fP 
.PP

.SS "void _wrewinddir (\fBWDIR_t\fP *)"

.PP
Sets the beginning in the directory stream\&. The \fCwrewinddir()\fP function flushes the current position of the stream to the beginning of the directory\&.
.PP
\fBsupport:\fP \fCLINUX\fP, \fCMSVC/MSVS\fP 
.SS "void _wseekdir (\fBWDIR_t\fP *, long int)"

.PP
Sets the position in the directory stream\&. The \fB_wseekdir\fP function sets the position in the directory stream from which the next call to \fB_wreaddir\fP will begin\&. The position argument must be a value that is returned by the previously called \fB_wtelldir\fP function\&.
.PP
\fBsupport:\fP \fCLINUX\fP 
.SS "int _wstat (const wchar_t *, void *)"

.PP
Functions \fCwstat*()\fP fill the structure with data about the file pointed to by \fCstruct stat\fP, associated with the file name\&. 
.PP
\fBReturns:\fP
.RS 4
If stat is successfully populated, \fC0\fP is returned\&. In case of failure, \fC-1\fP is returned, and \fCerrno\fP is set to \fCENOENT\fP\&.
.RE
.PP
\fBNote:\fP
.RS 4
The operation of the functions \fCwstat*()\fP is completely analogous to the function \fCstat()\fP
.RE
.PP
.IP "\(bu" 2
\fBwstat manual\fP 
.PP

.SS "int _wstat_s (const wchar_t *, size_t, void *)"

.PP
The same as \fB_wstat\fP, the \fCsize_t\fP parameter must contain the length of the variable of the file name, or zero\&. 
.IP "\(bu" 2
\fBwstat manual\fP 
.PP

.SS "int _wstat_selector (int, const void *, size_t, const void *)"

.PP
Automatic type selector for \fCwstat*\fP functions\&. 
.IP "\(bu" 2
\fBwstat manual\fP 
.PP

.SS "int _wstat_ws (const \fBstring_ws\fP *, void *)"

.PP
The same as \fB_wstat\fP, the input parameter filename is passed in the \fC\fBstring_ws\fP\fP structure\&. 
.IP "\(bu" 2
\fBwstat manual\fP 
.PP

.SS "long int _wtelldir (\fBWDIR_t\fP *)"

.PP
Returns the current position of the directory stream\&. If successful, the \fCwtelldir()\fP function returns the current location in the directory stream\&. In case of an error, \fC-1\fP is returned, and the corresponding value of \fCerrno\fP is set\&.
.PP
\fBsupport:\fP \fCLINUX\fP 
.SS "size_t u8stowcs (wchar_t *, const char *)"

.PP
Covert utf-8 char* to wchar_t* wchar_t* - output const char* - input return size_t - size\&. 
.PP
\fBNote:\fP
.RS 4
function u8stowcs requires to free the returned result 
.RE
.PP

.SS "\fBaccess_e\fP u8waccess (const wchar_t *, int)"

.PP
Check permissions for a file or directory, convert file name from wide characters to UTF-8\&. 
.PP
\fBAttention:\fP
.RS 4
function u8waccess requires to free the returned result 
.RE
.PP

.SS "FILE* u8wfopen (const wchar_t *, const wchar_t *)"

.PP
Open file stream, after converting the file name from wide characters to UTF-8\&. 
.PP
\fBAttention:\fP
.RS 4
function \fCu8wfopen\fP requires to free the returned result 
.RE
.PP

.SS "int u8wmkdir (const wchar_t *, mode_t)"

.PP
Creates a directory or a chain of directories specified in the path, after converting the file name from wide characters to UTF-8\&. 
.PP
\fBAttention:\fP
.RS 4
function \fCu8wmkdir\fP requires to free the returned result 
.RE
.PP

.SS "char* u8wpathnormalize (const wchar_t *)"

.PP
Normalize slash from path, convert file name from wide characters to UTF-8\&. 
.PP
\fBAttention:\fP
.RS 4
function u8wpathnormalize requires to free the returned result 
.RE
.PP

.SS "int u8wremove (const wchar_t *)"

.PP
Delete (remove) file or directory, after converting the file name from wide characters to UTF-8\&. 
.PP
\fBAttention:\fP
.RS 4
function \fCu8wremove\fP requires to free the returned result 
.RE
.PP

.SS "int u8wrename (const wchar_t *, const wchar_t *)"

.PP
Rename file, after converting the file name from wide characters to UTF-8\&. 
.PP
\fBAttention:\fP
.RS 4
function \fCu8wrename\fP requires to free the returned result 
.RE
.PP

.SS "int u8wstat (const wchar_t *, void *)"

.PP
Get file statistics by first converting the file name from wide characters to UTF-8\&. 
.PP
\fBAttention:\fP
.RS 4
Function \fCu8wstat\fP requires to free the returned result 
.RE
.PP

.SS "void wcprint (wchar_t *)"

.PP
wchar_t* print This function to test variably only! Instead use _vfprintf, _vfwprintf, _fprintf, _fwprintf 
.PP
\fBOther non standart functions\fP
.RS 4

.RE
.PP

.SS "wchar_t* wcsregexp (wchar_t * restrict, wchar_t * restrict, int *)"

.PP
wcsregexp - Matches a regular expression Original name: aov-rx - Angel Ortega's regular expression library Copyright (C) 2011/2012 Angel Ortega angel@triptico.com https://github.com/angelortega/aov-rx or http://triptico.com
.PP
\fBParameters:\fP
.RS 4
\fIrx\fP the regular expression 
.br
\fItx\fP the text to be matched 
.br
\fIsize\fP a pointer to integer where the matching lenght is stored
.RE
.PP
Matches the string tx for the regular expression in rx\&. On output, the integer pointer by size will contain the number of matched characters (with 0 meaning that no matching was possible)\&. If the end of string mark ($) is used in the regular expression and a match is effective, the ending zero is included in the match\&.
.PP
Returns the address of the match\&. 
.SS "size_t wcstou8s (char *, const wchar_t *)"

.PP
Convert wchar_t* to utf-8 char* char* - output const wchar_t* - input return size_t - size\&. 
.PP
\fBNote:\fP
.RS 4
function wcstou8s requires to free the returned result 
.RE
.PP

.SS "size_t wstring_append (\fBstring_ws\fP *, const wchar_t * restrict, size_t)"

.PP
Append string: \fCwchar_t*\fP, lenght input, \fCstruct \fBstring_ws\fP\fP output\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdestination\fP \fBstring_ws\fP 
.br
\fIsource\fP String type \fCwchar_t*\fP\&. 
.br
\fIlenght\fP Lenght of \fCsource\fP string\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
lenght of \fCoutput\fP produced\&.
.RE
.PP
\fBAttention:\fP
.RS 4
function \fC\fBwstring_append()\fP\fP requires to free the returned result 
.RE
.PP

.SS "size_t wstring_append_cvt (\fBstring_ws\fP *, const char * restrict, size_t)"

.PP
Append string: source type \fCchar*\fP, lenght input, \fCstruct \fBstring_ws\fP\fP output\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdestination\fP \fBstring_ws\fP 
.br
\fIsource\fP String type \fCchar*\fP\&. 
.br
\fIlenght\fP Lenght of \fCsource\fP string\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
lenght of \fCoutput\fP produced\&.
.RE
.PP
\fBAttention:\fP
.RS 4
function \fC\fBwstring_append_cvt()\fP\fP requires to free the returned result 
.RE
.PP

.SS "size_t wstring_appends_ (\fBstring_ws\fP *,  \&.\&.\&.)"

.PP
Append strings, only \fCwchar_t*\fP strings args inputs, \fCstruct \fBstring_ws\fP\fP output\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdestination\fP \fBstring_ws\fP 
.br
\fIarguments\fP Strings type \fCwchar_t*\fP, 126 max\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
lenght of \fCoutput\fP produced\&.
.RE
.PP
\fBNote:\fP
.RS 4
Do not use this function directly, first use the \fC\fBwstring_appends()\fP\fP macro, or end the last function's parameters with a value of NULL\&. 
.RE
.PP
\fBAttention:\fP
.RS 4
function \fC\fBwstring_appends_()\fP\fP requires to free the returned result 
.RE
.PP

.SS "size_t wstring_cstows (wchar_t[], size_t, const char * restrict, size_t)"

.PP
Converting string, char input, wchar_t array output, to alloc buffer write\&. 
.SS "wchar_t* wstring_cstows_alloc (const char * restrict)"

.PP
Converting string, char input, wchar_t allocate output\&. 
.PP
\fBAttention:\fP
.RS 4
function wstring_cstows_alloc requires to free the returned result 
.RE
.PP

.SS "size_t wstring_cstows_ws_alloc (\fBstring_ws\fP * restrict, const char * restrict)"

.PP
Converting string, \fBstring_ws\fP input, length output\&. 
.PP
\fBAttention:\fP
.RS 4
function wstring_cstows_alloc requires to free the returned result 
.RE
.PP

.SS "size_t wstring_format (\fBstring_ws\fP *, const wchar_t * restrict,  \&.\&.\&.)"

.PP
Append string, format \fCvargs\fP support input, \fCstruct \fBstring_ws\fP\fP output\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdestination\fP \fBstring_ws\fP 
.br
\fIformat\fP String type \fCwchar_t*\fP\&. 
.br
\fIarguments\fP Arguments support to \fCvargs\fP types, 125 max\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
lenght of \fCoutput\fP produced\&.
.RE
.PP
\fBAttention:\fP
.RS 4
curent status: broken, if out data large 8192 byte! Now, fixing output buffer size 8192 byte for *nix version\&. For MinGW32 always fixing output buffer size 8192 byte\&. TODO: rewrite length detected for *nix 
.RE
.PP

.SS "void wstring_free (\fBstring_ws\fP * restrict)"

.PP
Memory free string, empty and clear struct \fBstring_ws\fP\&. 
.SH "API use structure string_ws"
.PP
.SS "Allocate memory functions"

.SS "int wstring_isempty (const wchar_t *restrict s, int)"

.PP
Check wchar_t input string is empty, bool return\&. 
.SS "char* wstring_swstocs_alloc (const \fBstring_ws\fP * restrict)"

.PP
Converting string, \fBstring_ws\fP input, char allocate output\&. 
.PP
\fBAttention:\fP
.RS 4
function wstring_swstocs_alloc requires to free the returned result 
.RE
.PP

.SS "wchar_t* wstring_timeformat (const wchar_t * restrict, size_t, const wchar_t * restrict, const wchar_t * restrict)"

.PP
Converting time format string to string, wchar_t and size_t input\&. 
.PP
\fBAttention:\fP
.RS 4
function wstring_timeformat requires to free the returned result 
.RE
.PP

.SS "wchar_t* wstring_timeformat_ws (const \fBstring_ws\fP * restrict, const wchar_t * restrict, const wchar_t * restrict)"

.PP
Converting time format string to string, \fBstring_ws\fP input\&. 
.PP
\fBAttention:\fP
.RS 4
function wstring_timeformat_ws requires to free the returned result 
.RE
.PP

.SS "char* wstring_wstocs_alloc (const wchar_t * restrict)"

.PP
Converting string, wchar_t input, char allocate output\&. 
.PP
\fBAttention:\fP
.RS 4
function wstring_wstocs_alloc requires to free the returned result 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libwchar2 0\&.0\&.8 from the source code\&.
